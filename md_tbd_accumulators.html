<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quetzal-CoaTL: Polymorphism statistics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-darkmode-toggle.js" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<a href="https://github.com/Quetzal-framework/quetzal-CoaTL" class="github-corner" aria-label="View source on GitHub">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body">
    </path>
  </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quetzal-coaltl-fa.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quetzal-CoaTL
   </div>
   <div id="projectbrief">The Coalescence Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_tbd_accumulators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Polymorphism statistics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes how to use Quetzal.Accumulators to perform incremental statistical computations on genetic data.</p>
<h1><a class="anchor" id="autotoc_md117"></a>
Hello world!</h1>
<p>Below is a complete example of how to use the Accumulators Framework and the Statistical Accumulators to perform an incremental statistical calculation. It calculates the Tajima's D and its dependent statistics, add internal variables to the cache and also compute FST.</p>
<p>include example/stats.cpp</p>
<p>Expected output:</p>
<p>include example/results/stats.txt</p>
<h1><a class="anchor" id="autotoc_md118"></a>
Motivations</h1>
<p>To our knowledge, there is no existing resource that can compute summary statistics on genetic data in a satisfying way.</p>
<p>By satisfying, we mean that:</p>
<ul>
<li>statistics the user is not interested in should be <em>free</em> (no extra space or runtime cost)</li>
<li>the statistical framework should be extensible to new/exotic markers and genetic systems</li>
<li>it should be easy for a user with a new statistics to incorporate it in the framework</li>
<li>statistical analysis should <em>digest</em> the data, not hold onto them.</li>
</ul>
<h1><a class="anchor" id="autotoc_md119"></a>
Implementation</h1>
<p>The Quetzal Accumulators extends the same Boost Accumulators framework to perform incremental calculations. Usage of the framework follows the following pattern:</p>
<ol type="1">
<li>Users build a computational object, called an <code>accumulator_set&lt;&gt;</code>, by selecting the computations in which they are interested, or authoring their own computational primitives which fit within the framework.</li>
<li>Users push data into the <code>accumulator_set&lt;&gt;</code> object one sample at a time.</li>
<li>The <code>accumulator_set&lt;&gt;</code> computes the requested quantities in the most efficient method possible, resolving dependencies between requested calculations, possibly caching intermediate results.</li>
<li>The Accumulators Framework defines the utilities needed for defining primitive computational elements, called accumulators. It also provides the <code>accumulator_set&lt;&gt;</code> type, described above.</li>
</ol>
<h1><a class="anchor" id="autotoc_md120"></a>
Â Terminology</h1>
<p>For sake of consistency, we use the same terms as Boost Accumulators in the rest of the documentation.</p>
<ul>
<li><b>Sample</b>: A datum that is pushed into an <code>accumulator_set&lt;&gt;</code>. The type of the sample is the sample type.</li>
<li><b>Weight</b>: An optional scalar value passed along with the sample specifying the weight of the sample. Conceptually, each sample is multiplied with its weight. The type of the weight is the weight type.</li>
<li><b>Feature</b>: An abstract primitive computational entity. When defining an <code>accumulator_set&lt;&gt;</code>, users specify the features in which they are interested, and the <code>accumulator_set&lt;&gt;</code> figures out which accumulators would best provide those features. Features may depend on other features. If they do, the accumulator set figures out which accumulators to add to satisfy the dependencies.</li>
<li><b>Accumulator</b>: A concrete primitive computational entity. An accumulator is a concrete implementation of a feature. It satisfies exactly one abstract feature. Several different accumulators may provide the same feature, but may represent different implementation strategies.</li>
<li><b>Accumulator Set</b>: A collection of accumulators. An accumulator set is specified with a sample type and a list of features. The accumulator set uses this information to generate an ordered set of accumulators depending on the feature dependency graph. An accumulator set accepts samples one datum at a time, propagating them to each accumulator in order. At any point, results can be extracted from the accumulator set.</li>
<li><b>Extractor</b>: A function or function object that can be used to extract a result from an <code>accumulator_set&lt;&gt;</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md121"></a>
Overview</h1>
<p>Here is a list of the important types and functions in the Accumulator Framework and a brief description of each.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Tool   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>accumulator_set&lt;&gt;</code>   </td><td class="markdownTableBodyNone">This is the most important type in the Accumulators Framework. <br  />
It is a collection of accumulators. A datum pushed into an<br  />
<code>accumulator_set&lt;&gt;</code> is forwarded to each accumulator, in an<br  />
order determined by the dependency relationships between the <br  />
accumulators. Computational results can be extracted from an <br  />
accumulator at any time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>depends_on&lt;&gt;</code>   </td><td class="markdownTableBodyNone">Used to specify which other features a feature depends on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>feature_of&lt;&gt;</code>   </td><td class="markdownTableBodyNone">Trait used to tell the Accumulators Framework that, for the <br  />
purpose of feature-based dependency resolution, one feature <br  />
should be treated the same as another.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>as_feature&lt;&gt;</code>   </td><td class="markdownTableBodyNone">Used to create an alias for a feature. For example, if there<br  />
are two features, <code>fast_X</code> and <code>accurate_X</code>, they can be mapped<br  />
to <code>X(fast)</code> and <code>X(accurate)</code> with <code>as_feature&lt;&gt;</code>. This is just<br  />
syntactic sugar.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>features&lt;&gt;</code>   </td><td class="markdownTableBodyNone">An MPL sequence. We can use <code>features&lt;&gt;</code> as the second template<br  />
parameter when declaring an accumulator_set&lt;&gt;.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>external&lt;&gt;</code>   </td><td class="markdownTableBodyNone">Used when declaring an <code>accumulator_set&lt;&gt;</code>. If the weight type <br  />
is specified with <code>external&lt;&gt;</code>, then the weight accumulators <br  />
are assumed to reside in a separate accumulator set which will<br  />
be passed in with a named parameter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extractor&lt;&gt;</code>   </td><td class="markdownTableBodyNone">A class template useful for creating an extractor function <br  />
object. It is parameterized on a feature, and it has member <br  />
functions for extracting from an <code>accumulator_set&lt;&gt;</code> the <br  />
result corresponding to that feature.   </td></tr>
</table>
<p>Using accumulator_set&lt;&gt; Our tour of the accumulator_set&lt;&gt; class template begins with the forward declaration:</p>
<p>template&lt; typename Sample, typename Features, typename Weight = void &gt; struct accumulator_set; The template parameters have the following meaning:</p>
<p>Sample The type of the data that will be accumulated.</p>
<p>Features An MPL sequence of features to be calculated.</p>
<p>Weight The type of the (optional) weight paramter.</p>
<p>For example, the following line declares an accumulator_set&lt;&gt; that will accept a sequence of doubles one at a time and calculate the min and mean:</p>
<p>accumulator_set&lt; double, features&lt; tag::min, tag::mean &gt; &gt; acc; Notice that we use the features&lt;&gt; template to specify a list of features to be calculated. features&lt;&gt; is an MPL sequence of features.</p>
<p>[Note] Note features&lt;&gt; is a synonym of mpl::vector&lt;&gt;. In fact, we could use mpl::vector&lt;&gt; or any MPL sequence if we prefer, and the meaning would be the same.</p>
<p>Once we have defined an accumulator_set&lt;&gt;, we can then push data into it, and it will calculate the quantities you requested, as shown below.</p>
<p>// push some data into the accumulator_set ... acc(1.2); acc(2.3); acc(3.4); Since accumulator_set&lt;&gt; defines its accumulate function to be the function call operator, we might be tempted to use an accumulator_set&lt;&gt; as a UnaryFunction to a standard algorithm such as std::for_each. That's fine as long as we keep in mind that the standard algorithms take UnaryFunction objects by value, which involves making a copy of the accumulator_set&lt;&gt; object. Consider the following:</p>
<p>// The data for which we wish to calculate statistical properties: std::vector&lt; double &gt; data( /* stuff */ );</p>
<p>// The accumulator set which will calculate the properties for us: accumulator_set&lt; double, features&lt; tag::min, tag::mean &gt; &gt; acc;</p>
<p>// Use std::for_each to accumulate the statistical properties: acc = std::for_each( data.begin(), data.end(), acc ); Notice how we must assign the return value of std::for_each back to the accumulator_set&lt;&gt;. This works, but some accumulators are not cheap to copy. For example, the tail and tail_variate&lt;&gt; accumulators must store a std::vector&lt;&gt;, so copying these accumulators involves a dynamic allocation. We might be better off in this case passing the accumulator by reference, with the help of boost::bind() and boost::ref(). See below:</p>
<p>// The data for which we wish to calculate statistical properties: std::vector&lt; double &gt; data( /* stuff */ );</p>
<p>// The accumulator set which will calculate the properties for us: accumulator_set&lt; double, features&lt; tag::tail&lt;left&gt; &gt; &gt; acc( tag::tail&lt;left&gt;::cache_size = 4 );</p>
<p>// Use std::for_each to accumulate the statistical properties: std::for_each( data.begin(), data.end(), bind&lt;void&gt;( ref(acc), _1 ) ); Notice now that we don't care about the return value of std::for_each() anymore because std::for_each() is modifying acc directly.</p>
<p>[Note] Note To use boost::bind() and boost::ref(), you must #include &lt;boost/bind.hpp&gt; and &lt;boost/ref.hpp&gt;</p>
<p>Extracting Results Once we have declared an accumulator_set&lt;&gt; and pushed data into it, we need to be able to extract results from it. For each feature we can add to an accumulator_set&lt;&gt;, there is a corresponding extractor for fetching its result. Usually, the extractor has the same name as the feature, but in a different namespace. For example, if we accumulate the tag::min and tag::max features, we can extract the results with the min and max extractors, as follows:</p>
<p>// Calculate the minimum and maximum for a sequence of integers. accumulator_set&lt; int, features&lt; tag::min, tag::max &gt; &gt; acc; acc( 2 ); acc( -1 ); acc( 1 );</p>
<p>// This displays "(-1, 2)" std::cout &lt;&lt; '(' &lt;&lt; min( acc ) &lt;&lt; ", " &lt;&lt; max( acc ) &lt;&lt; ")\n"; The extractors are all declared in the boost::accumulators::extract namespace, but they are brought into the boost::accumulators namespace with a using declaration.</p>
<p>[Tip] Tip On the Windows platform, min and max are preprocessor macros defined in WinDef.h. To use the min and max extractors, you should either compile with NOMINMAX defined, or you should invoke the extractors like: (min)( acc ) and (max)( acc ). The parentheses keep the macro from being invoked.</p>
<p>Another way to extract a result from an accumulator_set&lt;&gt; is with the extract_result() function. This can be more convenient if there isn't an extractor object handy for a certain feature. The line above which displays results could equally be written as:</p>
<p>// This displays "(-1, 2)" std::cout &lt;&lt; '(' &lt;&lt; extract_result&lt; tag::min &gt;( acc ) &lt;&lt; ", " &lt;&lt; extract_result&lt; tag::max &gt;( acc ) &lt;&lt; ")\n"; Finally, we can define our own extractor using the extractor&lt;&gt; class template. For instance, another way to avoid the min / max macro business would be to define extractors with names that don't conflict with the macros, like this:</p>
<p>extractor&lt; tag::min &gt; min_; extractor&lt; tag::min &gt; max_;</p>
<p>// This displays "(-1, 2)" std::cout &lt;&lt; '(' &lt;&lt; min_( acc ) &lt;&lt; ", " &lt;&lt; max_( acc ) &lt;&lt; ")\n"; Passing Optional Parameters Some accumulators need initialization parameters. In addition, perhaps some auxiliary information needs to be passed into the accumulator_set&lt;&gt; along with each sample. Boost.Accumulators handles these cases with named parameters from the Boost.Parameter library.</p>
<p>For example, consider the tail and tail_variate&lt;&gt; features. tail keeps an ordered list of the largest N samples, where N can be specified at construction time. Also, the tail_variate&lt;&gt; feature, which depends on tail, keeps track of some data that is covariate with the N samples tracked by tail. The code below shows how this all works, and is described in more detail below.</p>
<p>// Define a feature for tracking covariate data typedef tag::tail_variate&lt; int, tag::covariate1, left &gt; my_tail_variate_tag;</p>
<p>// This will calculate the left tail and my_tail_variate_tag for N == 2 // using the tag::tail&lt;left&gt;::cache_size named parameter accumulator_set&lt; double, features&lt; my_tail_variate_tag &gt; &gt; acc( tag::tail&lt;left&gt;::cache_size = 2 );</p>
<p>// push in some samples and some covariates by using // the covariate1 named parameter acc( 1.2, covariate1 = 12 ); acc( 2.3, covariate1 = -23 ); acc( 3.4, covariate1 = 34 ); acc( 4.5, covariate1 = -45 );</p>
<p>// Define an extractor for the my_tail_variate_tag feature extractor&lt; my_tail_variate_tag &gt; my_tail_variate;</p>
<p>// Write the tail statistic to std::cout. This will print "4.5, 3.4, " std::ostream_iterator&lt; double &gt; dout( std::cout, ", " ); std::copy( tail( acc ).begin(), tail( acc ).end(), dout );</p>
<p>// Write the tail_variate statistic to std::cout. This will print "-45, 34, " std::ostream_iterator&lt; int &gt; iout( std::cout, ", " ); std::copy( my_tail_variate( acc ).begin(), my_tail_variate( acc ).end(), iout ); There are several things to note about the code above. First, notice that we didn't have to request that the tail feature be calculated. That is implicit because the tail_variate&lt;&gt; feature depends on the tail feature. Next, notice how the acc object is initialized: acc( tag::tail&lt;left&gt;::cache_size = 2 ). Here, cache_size is a named parameter. It is used to tell the tail and tail_variate&lt;&gt; accumulators how many samples and covariates to store. Conceptually, every construction parameter is made available to every accumulator in an accumulator set.</p>
<p>We also use a named parameter to pass covariate data into the accumulator set along with the samples. As with the constructor parameters, all parameters to the accumulate function are made available to all the accumulators in the set. In this case, only the accumulator for the my_tail_variate feature would be interested in the value of the covariate1 named parameter.</p>
<p>We can make one final observation about the example above. Since tail and tail_variate&lt;&gt; are multi-valued features, the result we extract for them is represented as an iterator range. That is why we can say tail( acc ).begin() and tail( acc ).end().</p>
<p>Even the extractors can accept named parameters. In a bit, we'll see a situation where that is useful.</p>
<p>Weighted Samples Some accumulators, statistical accumulators in particular, deal with data that are weighted. Each sample pushed into the accumulator has an associated weight, by which the sample is conceptually multiplied. The Statistical Accumulators Library provides an assortment of these weighted statistical accumulators. And many unweighted statistical accumulators have weighted variants. For instance, the weighted variant of the sum accumulator is called weighted_sum, and is calculated by accumulating all the samples multiplied by their weights.</p>
<p>To declare an accumulator_set&lt;&gt; that accepts weighted samples, you must specify the type of the weight parameter as the 3rd template parameter, as follows:</p>
<p>// 3rd template parameter 'int' means this is a weighted // accumulator set where the weights have type 'int' accumulator_set&lt; int, features&lt; tag::sum &gt;, int &gt; acc; When you specify a weight, all the accumulators in the set are replaced with their weighted equivalents. For example, the above accumulator_set&lt;&gt; declaration is equivalent to the following:</p>
<p>// Since we specified a weight, tag::sum becomes tag::weighted_sum accumulator_set&lt; int, features&lt; tag::weighted_sum &gt;, int &gt; acc; When passing samples to the accumulator set, you must also specify the weight of each sample. You can do that with the weight named parameter, as follows:</p>
<p>acc(1, weight = 2); // 1 * 2 acc(2, weight = 4); // 2 * 4 acc(3, weight = 6); // + 3 * 6 // ----&mdash; // = 28 You can then extract the result with the sum() extractor, as follows:</p>
<p>// This prints "28" std::cout &lt;&lt; sum(acc) &lt;&lt; std::endl; [Note] Note When working with weighted statistical accumulators from the Statistical Accumulators Library, be sure to include the appropriate header. For instance, weighted_sum is defined in &lt;boost/accumulators/statistics/weighted_sum.hpp&gt;. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
