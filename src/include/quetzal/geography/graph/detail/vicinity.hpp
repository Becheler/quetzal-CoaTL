// Copyright 2021 Arnaud Becheler    <abechele@umich.edu>

///////////////////////////////////////////////////////////////////////////                                                                       *
/// This program is free software; you can redistribute it and/or modify ///
/// it under the terms of the GNU General Public License as published by ///
/// the Free Software Foundation; either version 2 of the License, or    ///
/// (at your option) any later version.                                  ///
///                                                                     ///
///////////////////////////////////////////////////////////////////////////

#pragma once

#include "concepts.hpp"

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/adjacency_matrix.hpp>

namespace quetzal::geography
{
  /// @brief Policy class to connect vertices of a complete graph
  /// @tparam VertexProperty Vertex information
  /// @tparam EdgeProperty Edge information
  template <class VertexProperty, class EdgeProperty>
  struct connect_fully
  {
    /// @brief The type of graph generated by this policy
    /// @tparam T The directionality (isotropy or anisotropy)
    template <Directionality T>
    using graph_type = boost::adjacency_matrix< // dense
        boost::setS,                            // avoid parallel edges
        boost::vecS,                            // no reason to prefer listS
        T,
        VertexProperty,
        EdgeProperty>;

    /// @brief Connect vertices in a graph following the required concept of vicinity
    /// @tparam T The directionality (isotropy or anisotropy)
    /// @param graph The graph to be connected
    template <Directionality T>
    constexpr void connect(graph_type<T> & graph)
    {
      using directed_type = typename graph_type<T>::directed_type;
      for (auto s = 0; s < graph.num_vertices(); ++s)
      {
        for (auto t = s + 1; t < graph.num_vertices(); ++t)
        {
          graph.add_edge(s, t, EdgeProperty(s, t)); // (s -> v) == (s <- v) if undirected
          if constexpr (std::same_as<directed_type, anisotropy>) 
            graph.add_edge(t, s, EdgeProperty(t, s)); // (s -> v) != (s <- v) because directed
        }
      }
    }

  };

  /// @brief Policy class to connect vertices of a graph to their 4 cardinal neighbors.
  /// @tparam VertexProperty Vertex information
  /// @tparam EdgeProperty Edge information
  template <class VertexProperty, class EdgeProperty>
  class connect_4_neighbors
  {
    public:

    /// @brief The type of graph generated by this policy
    /// @tparam T The directionality (isotropy or anisotropy)
    template <Directionality T>
    using graph_type = boost::adjacency_list< // sparse
      boost::setS,                          // avoid parallel edges
      boost::vecS,                          // no reason to prefer listS
      T,
      VertexProperty,
      EdgeProperty>;

    private:

    template <Directionality T>
    using vertex_descriptor = graph_type<T>::vertex_descriptor;

    template <Directionality T>
    using directed_type = typename graph_type<T>::directed_type;

    template <Directionality T>
    void connect(vertex_descriptor<T> s, vertex_descriptor<T> t, graph_type<T> & graph, const SpatialGrid auto & grid)
    {
      graph.add_edge(s, t, EdgeProperty(s, t));
      if constexpr (std::same_as<directed_type<T>, anisotropy>)
        graph.add_edge(t, s, EdgeProperty(t, s)); // (s -> v) != (s <- v) because directed
    }
    
    template <Directionality T>
    void connect_top_left_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s+ 1, graph, grid);
      connect(s, s + grid.width(), graph, grid);
    }
    
    template <Directionality T>
    void connect_top_right_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);
      connect(s, s + grid.width(), graph, grid);
    }
    
    template <Directionality T>
    void connect_top_border_no_corners(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s -1, graph, grid);   
      connect(s, s + 1, graph, grid);   
      connect(s, s + grid.width(), graph, grid);  
    }

    template <Directionality T>   
    void connect_bottom_left_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1, graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
    }

    template <Directionality T>   
    void connect_bottom_right_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
    }

    template <Directionality T>
    void connect_bottom_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);   
      connect(s, s + 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
    }
    
    template <Directionality T>
    void connect_left_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s + grid.width(), graph, grid);  
    }
    
    template <Directionality T>
    void connect_right_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s + grid.width(), graph, grid);  
    }
    
    template <Directionality T>
    void connect_interior_vertices(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1 , graph, grid);   
      connect(s, s - 1 , graph, grid);   
      connect(s, s + grid.width(), graph, grid);  
      connect(s, s - grid.width(), graph, grid);  
    }

    public:

    /// @brief Connect vertices in a graph to its neighbors following the required concept of vicinity
    /// @param graph The graph with \f$n\f$ vertices to be connected
    /// @param grid The spatial grid with \f$n\f$ cells
    /// @param bound_policy Policy delegating the connection of border vertices. 
    template <Directionality T>
    constexpr void connect(graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      int width = grid.width();
      int height = grid.height();

      for (auto s = 0; s < graph.num_vertices(); ++s)
      {
        int row = s / width;
        int col = s % width;

        if (row == 0)
        {
          if (col == 0)
          {
            connect_top_left_corner(s, graph, grid, bound_policy);
          }
          else if (col == width - 1)
          {
            connect_top_right_corner(s, graph, grid, bound_policy);
          }
          else
          {
            connect_top_border_no_corners(s, graph, grid, bound_policy);
          }
        }
        else if (row == height - 1)
        {
          if (col == 0)
          {
            connect_bottom_left_corner(s, graph, grid, bound_policy);
          }
          else if (col == width - 1)
          {
            connect_bottom_right_corner(s, graph, grid, bound_policy);
          }
          else
          {
            connect_bottom_border_no_corner(s, graph, grid, bound_policy);
          }
        }
        else if (col == 0)
        {
          connect_left_border_no_corner(s, graph, grid, bound_policy);
        }
        else if (col == width - 1)
        {
          connect_right_border_no_corner(s, graph, grid, bound_policy);
        }
        else
        {
          connect_interior_vertices(s, graph);
        }
      }
    }
  };

  /// @brief Policy class to connect vertices of a spatial graph to their 4 cardinal and 4 inter-cardinal neighbors.
  /// @tparam VertexProperty Vertex information
  /// @tparam EdgeProperty Edge information
  template <class VertexProperty, class EdgeProperty>
  class connect_8_neighbors
  {
    public:

    /// @brief Type of graph generated by the policy
    /// @tparam T 
    template <Directionality T>
    using graph_type = boost::adjacency_list< // sparse
      boost::setS,                          // avoid parallel edges
      boost::vecS,                          // no reason to prefer listS
      T,
      VertexProperty,
      EdgeProperty>;

    private:

    template <Directionality T>
    using vertex_descriptor = graph_type<T>::vertex_descriptor;

    template <Directionality T>
    using directed_type = typename graph_type<T>::directed_type;

    template <Directionality T>
    void connect(vertex_descriptor<T> s, vertex_descriptor<T> t, graph_type<T> & graph, const SpatialGrid auto & grid)
    {
      graph.add_edge(s, t, EdgeProperty(s, t));
      if constexpr (std::same_as<directed_type<T>, anisotropy>)
        graph.add_edge(t, s, EdgeProperty(t, s)); // (s -> v) != (s <- v) because directed
    }

    template <Directionality T>
    void connect_top_left_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s+ 1, graph, grid);
      connect(s, s + grid.width(), graph, grid);
      connect(s, s + grid.width() + 1, graph, grid);
    }
    
    template <Directionality T>
    void connect_top_right_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);
      connect(s, s + grid.width(), graph, grid);
      connect(s, s + grid.width() - 1 , graph, grid);
    }

    template <Directionality T>
    void connect_top_border_no_corners(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s -1, graph, grid);   
      connect(s, s + 1, graph, grid);   
      connect(s, s + grid.width(), graph, grid);
      connect(s, s + grid.width() - 1, graph, grid);  
      connect(s, s + grid.width() + 1, graph, grid);  
    }

    template <Directionality T>
    void connect_bottom_left_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1, graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s - grid.width() + 1, graph, grid);  
    }

    template <Directionality T>
    void connect_bottom_right_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);   
      connect(s, s - grid.width(), graph, grid);
      connect(s, s - grid.width() - 1, graph, grid);  
    }

    template <Directionality T>
    void connect_bottom_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1, graph, grid);   
      connect(s, s + 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);
      connect(s, s + grid.width() - 1, graph, grid);  
      connect(s, s + grid.width() + 1, graph, grid);  
    }

    template <Directionality T>
    void connect_left_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s + grid.width(), graph, grid);  
      connect(s, s - grid.width() + 1, graph, grid);  
      connect(s, s + grid.width() + 1, graph, grid);  
    }

    template <Directionality T>
    void connect_right_border_no_corner(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s - 1 , graph, grid);   
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s + grid.width(), graph, grid);
      connect(s, s - grid.width() - 1, graph, grid);  
      connect(s, s + grid.width() - 1, graph, grid);    
    }

    template <Directionality T>
    void connect_interior_vertices(vertex_descriptor<T> s, graph_type<T> & graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      bound_policy(s, graph, grid);
      connect(s, s + 1 , graph, grid);   
      connect(s, s - 1 , graph, grid);   
      connect(s, s + grid.width(), graph, grid);  
      connect(s, s + grid.width() + 1, graph, grid);  
      connect(s, s + grid.width() - 1, graph, grid);  
      connect(s, s - grid.width(), graph, grid);  
      connect(s, s - grid.width() + 1, graph, grid);  
      connect(s, s - grid.width() - 1, graph, grid);  
    }

    public:

    /// @brief Connect vertices of a graph to its neighbors according to the required policy.
    /// @param graph The graph with \f$n\f$ vertices to be connected
    /// @param grid The spatial grid with \f$n\f$ cells
    /// @param bound_policy Policy delegating the connection of border vertices. 
    template <Directionality T>
    constexpr void connect(graph_type<T> &graph, const SpatialGrid auto & grid, BoundPolicy<decltype(grid), graph_type<T>> auto bound_policy)
    {
      int width = grid.width();
      int height = grid.height();

      for (auto s = 0; s < graph.num_vertices(); ++s)
      {
        int row = s / width;
        int col = s % width;

        if (row == 0)
        {
          if (col == 0)
          {
            connect_top_left_corner(s, graph, grid, bound_policy);
          }
          else if (col == width - 1)
          {
            connect_top_right_corner(s, graph, grid, bound_policy);
          }
          else
          {
            connect_top_border_no_corners(s, graph, grid, bound_policy);
          }
        }
        else if (row == height - 1)
        {
          if (col == 0)
          {
            connect_bottom_left_corner(s, graph, grid, bound_policy);
          }
          else if (col == width - 1)
          {
            connect_bottom_right_corner(s, graph, grid, bound_policy);
          }
          else
          {
            connect_bottom_border_no_corner(s, graph, grid, bound_policy);
          }
        }
        else if (col == 0)
        {
          connect_left_border_no_corner(s, graph, grid, bound_policy);
        }
        else if (col == width - 1)
        {
          connect_right_border_no_corner(s, graph, grid, bound_policy);
        }
        else
        {
          connect_interior_vertices(s, graph);
        }
      }
    }
  };

  namespace
  {
    template <Vicinity T>
    using Vicinity_checked = T;

    template <class V, class E>
    using Vicinity_t = Vicinity<connect_fully<V, E>>;

    template <class V, class E>
    using Vicinity_t = Vicinity<connect_4_neighbors<V, E>>;

    template <class V, class E>
    using Vicinity_t = Vicinity<connect_8_neighbors<V, E>>;
  }
}