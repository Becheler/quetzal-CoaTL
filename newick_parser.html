<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=9" />
  <meta name="generator" content="Doxygen 1.9.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quetzal-CoaTL: Parsing a Newick string</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-darkmode-toggle.js" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
  </script>
  <a href="https://github.com/Quetzal-framework/quetzal-CoaTL" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250"
      style="fill:#70B7FD; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
      <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
      <path
        d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
        fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
      <path
        d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
        fill="currentColor" class="octo-body">
      </path>
    </svg>
  </a>
  <style>
    .github-corner:hover .octo-arm {
      animation: octocat-wave 560ms ease-in-out
    }
    @keyframes octocat-wave {
      0%,
      100% {
        transform: rotate(0)
      }
      20%,
      60% {
        transform: rotate(-25deg)
      }
      40%,
      80% {
        transform: rotate(10deg)
      }
    }
    @media (max-width:500px) {
      .github-corner:hover .octo-arm {
        animation: none
      }
      .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
      }
    }
  </style>
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectlogo"><img alt="Logo" src="quetzal-coaltl-fa.png" /></td>
            <td id="projectalign" style="padding-left: 0.5em;">
              <div id="projectname">Quetzal-CoaTL
              </div>
              <div id="projectbrief">The Coalescence Template Library</div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('newick_parser.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Parsing a Newick string </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md37">Introduction</a><ul><li class="level3"><a href="#autotoc_md39">Background</a></li>
<li class="level3"><a href="#autotoc_md41">Grammar</a></li>
<li class="level3"><a href="#autotoc_md43">Objectives</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md45">To a Quetzal k-ary tree</a><ul><li class="level3"><a href="#autotoc_md47">Default properties</a></li>
<li class="level3"><a href="#autotoc_md49">Custom properties</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md51">Interfacing legacy code</a></li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md37"></a>
Introduction</h2>
<hr  />
<h3><a class="anchor" id="autotoc_md39"></a>
Background</h3>
<p>Newick tree format is a way of representing graph-theoretical trees with edge lengths using parentheses and commas.</p>
<p>Yet not very efficient, Newick is a simple and popular format for representing trees, and provides a rather useful abstraction in coalescence theory for representing the shared history of populations (species trees, population trees) or gene genealogies that coalesce into these trees.</p>
<p><b>Quetzal</b> provides some utilities to parse, generate and manipulate such format.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md41"></a>
Grammar</h3>
<p>Whitespace here refer to any of the following: spaces, tabs, carriage returns, and linefeeds.</p>
<ul>
<li>Whitespace within number is prohibited.</li>
<li>Whitespace outside of node names is ignored.</li>
<li>Grammar characters (semicolon, parentheses, comma, and colon) are prohibited</li>
<li>Comments are enclosed in square brackets.</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md43"></a>
Objectives</h3>
<p>In this tutorial section you will learn how to:</p><ul>
<li>Parse a Newick string to a <b>Quetzal</b> k-ary tree class,</li>
<li>Customize the default <b>Quetzal</b> tree properties to describe your data and problem correctly,</li>
<li>Parse a Newick string to your own legacy tree class</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md45"></a>
To a Quetzal k-ary tree</h2>
<hr  />
<h3><a class="anchor" id="autotoc_md47"></a>
Default properties</h3>
<p>In this example we will use the default (and simplistic) properties of the graph synthetized by the parsing. By <em>properties</em> we mean the type the data structures used to store arbitrary information along the vertices and edges of a graph.</p>
<p>For general graphs it could be anything, but since we are parsing Newick formats, we can reasonably expect <em>ad minima</em>:</p><ul>
<li>a <code>std::string</code> to describe a vertex (the <em>name</em> of the node)</li>
<li>a <code>double</code> to describe an edge (the <em>distance to a parent node</em>).</li>
</ul>
<p><b>Quetzal</b> defaults to these minima when it tries to build a tree from a Newick string.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In the next sections we will see that you can actually parse into more complex data structures - as long as vertices (<em>resp.</em> edges) remain constructible from a simple <code>std::string</code> (resp. <code>double</code>)!</dd></dl>
<p><b>Input</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &quot;quetzal/quetzal.hpp&quot;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// Define a namespace alias to shorten notation</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacequetzal_1_1format_1_1newick.html">newick</a> = <a class="code" href="namespacequetzal_1_1format_1_1newick.html">quetzal::format::newick</a>;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    std::string s1 = <span class="stringliteral">&quot;(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;&quot;</span>;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    std::string s2 = <span class="stringliteral">&quot;(,,(,));&quot;</span>;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="comment">// For default graph properties, leave &lt;&gt; empty</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keyword">auto</span> [tree1, root1] = newick::to_k_ary_tree&lt;&gt;(s1);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <span class="keyword">auto</span> [tree2, root2] = newick::to_k_ary_tree&lt;&gt;(s2);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;These graphs are &quot;</span> &lt;&lt; (tree1.is_isomorphic(tree2) ? <span class="stringliteral">&quot;toootally&quot;</span> : <span class="stringliteral">&quot;not&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; isomorphic!&quot;</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;              &lt;&lt; std::endl;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="ttc" id="anamespacequetzal_1_1format_1_1newick_html"><div class="ttname"><a href="namespacequetzal_1_1format_1_1newick.html">quetzal::format::newick</a></div><div class="ttdoc">Generic components for parsing or generating Newick strings.</div><div class="ttdef"><b>Definition:</b> ast.hpp:20</div></div>
</div><!-- fragment --><p><b>Output</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;3</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;2</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;3</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;2</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;These graphs are toootally isomorphic!</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md49"></a>
Custom properties</h3>
<p>In the previous example we used default types to represent the properties of a vertex and an edge. These defaults are useful, but not always sufficient. For example, you may want to visit your tree graph and trigger specific events when specific nodes or edges are visited.</p>
<p>In this case, you would need to define your own small structures to represent the graph properties you want:</p><ul>
<li>the vertex should be constructible from a <code>std::string</code></li>
<li>the edge should be constructible from a <code>double</code></li>
<li>the event would be to print to <code>std::cout</code> with a pretty display</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>You can think of pretty much any type of events here:<ul>
<li>convert the branch length to coalescence units, generations, etc</li>
<li>update a mutational state data member,</li>
<li>construct a slightly modified copy of the tree while visiting its clone</li>
<li>etc ...</li>
</ul>
</dd></dl>
<p><b>Input</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &quot;quetzal/quetzal.hpp&quot;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// Your custom little vertex class</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">struct </span><a class="code" href="structvertex__info.html">vertex_info</a></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    std::string name;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;};</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// Your custom little edge class</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">struct </span><a class="code" href="structedge__info.html">edge_info</a></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keywordtype">double</span> length;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// Make your custom vertex streamable for the visitor</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacequetzal_1_1demography.html#a1d9919bc738eed56d179b9801fa69ecb">operator&lt;&lt;</a>(std::ostream &amp;os, <a class="code" href="structvertex__info.html">vertex_info</a> <span class="keyword">const</span> &amp;v)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordflow">return</span> os &lt;&lt; quoted(v.name);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">// we want to trigger a custom event when a vertex is discovered by the DFS</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Graph&gt; <span class="keyword">struct </span><a class="code" href="structMyVisitor.html">MyVisitor</a></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;{</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    Graph &amp;_tree;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="structMyVisitor.html">MyVisitor</a>(Graph &amp;tree) : _tree(tree)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    }</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordtype">void</span> operator()(<span class="keyword">auto</span> stage, <span class="keyword">auto</span> vertex)</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="keywordflow">switch</span> (stage)</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordflow">case</span> boost::visit::pre:</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;            <span class="comment">// vertex_info g[u] is streamable!</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Discover vertex &quot;</span> &lt;&lt; vertex &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; _tree[vertex] &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">case</span> boost::visit::in:</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">case</span> boost::visit::post:</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;received invalid DFS order&quot;</span>);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;};</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">// Define a namespace alias to shorten notation</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacequetzal_1_1format_1_1newick.html">newick</a> = <a class="code" href="namespacequetzal_1_1format_1_1newick.html">quetzal::format::newick</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    std::string s = <span class="stringliteral">&quot;(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;&quot;</span>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="comment">// Inject your custom littles classes here: the parser will generate these</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">// structures and embed them into the graph.</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keyword">auto</span> [tree, root] = newick::to_k_ary_tree&lt;vertex_info, edge_info&gt;(s);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// depth-first traversal of the vertices in the directed graph</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="structMyVisitor.html">MyVisitor</a> visitor(tree);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    tree.depth_first_search(root, visitor);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div>
<div class="ttc" id="anamespacequetzal_1_1demography_html_a1d9919bc738eed56d179b9801fa69ecb"><div class="ttname"><a href="namespacequetzal_1_1demography.html#a1d9919bc738eed56d179b9801fa69ecb">quetzal::demography::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;stream, const FlowHashMapImplementation&lt; Space, Time, Value &gt; &amp;flows)</div><div class="ttdoc">Stream operator.</div><div class="ttdef"><b>Definition:</b> FlowHashMapImplementation.hpp:190</div></div>
<div class="ttc" id="astructMyVisitor_html"><div class="ttname"><a href="structMyVisitor.html">MyVisitor</a></div><div class="ttdef"><b>Definition:</b> newick_parser_2.cpp:24</div></div>
<div class="ttc" id="astructedge__info_html"><div class="ttname"><a href="structedge__info.html">edge_info</a></div><div class="ttdef"><b>Definition:</b> newick_parser_2.cpp:12</div></div>
<div class="ttc" id="astructvertex__info_html"><div class="ttname"><a href="structvertex__info.html">vertex_info</a></div><div class="ttdef"><b>Definition:</b> coalescence_binary_tree_2.cpp:5</div></div>
</div><!-- fragment --><p><b>Output</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;3</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;2</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Discover vertex 0 (<span class="stringliteral">&quot;F&quot;</span>)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Discover vertex 1 (<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Discover vertex 2 (&quot;B&quot;)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Discover vertex 3 (&quot;E&quot;)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Discover vertex 4 (&quot;C&quot;)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Discover vertex 5 (&quot;D&quot;)</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md51"></a>
Interfacing legacy code</h2>
<p>If you have been coding for a while, you may already depend heavily on your own class to describe a tree graph, and not feel very excited about refactoring your whole project to switch to <b>Quetzal</b> trees. Fair enough.</p>
<p>This section shows how to use <b>Quetzal</b> parser to populate your own legacy class and then forget about <b>Quetzal</b>.</p>
<ol type="1">
<li>You will need to parse Newick strings into an AST (Abstract Syntax Tree): this is a temporary data structure that represents the syntactic structure of the tree.</li>
<li>This AST can then be iterated over to convert it into the data structure of your choice.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li><b>Quetzal</b> does not know anything about your own classes, so you will need a bit of extra effort to write a recursion on the AST data</li>
<li>But at least you don't have to worry about the parsing logic anymore!</li>
<li>If the task becomes tedious, don't hesitate to <a href="https://github.com/Quetzal-framework/quetzal-CoaTL/issues">ask for help</a> !</li>
<li>On most compilers but Apple Clang, you could simplify the example code by writing: <code>subtree.left_child = std::make_unique&lt;<a class="el" href="structMyNode.html">MyNode</a>&gt;(ast.name, ast.distance_to_parent);</code> in the recursion function.</li>
</ol>
</dd></dl>
<p><b>Input</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &quot;quetzal/quetzal.hpp&quot;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// std::cout</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span>   <span class="comment">// std::unique_ptr</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Assume this binary tree class pervades your code</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">struct </span><a class="code" href="structMyNode.html">MyNode</a></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    std::string id;                     <span class="comment">// the vertex name</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <span class="keywordtype">double</span> length;                      <span class="comment">// the edge length</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    std::unique_ptr&lt;MyNode&gt; left_child; <span class="comment">// never use bare pointers in interfaces</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    std::unique_ptr&lt;MyNode&gt; right_child;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// Define a namespace alias to shorten notation</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacequetzal_1_1format_1_1newick.html">newick</a> = <a class="code" href="namespacequetzal_1_1format_1_1newick.html">quetzal::format::newick</a>;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    std::string s = <span class="stringliteral">&quot;(A:0.1,(C:0.3,D:0.4)B:0.5)E;&quot;</span>;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// We define a shorter type alias</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="keyword">using</span> ast_type = newick::ast::node;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="comment">// We initialize the root of Abstract Syntax Tree (AST)</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    ast_type ast;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="comment">// We parse the input string into the AST</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keyword">auto</span> ok = quetzal::parse(begin(s), end(s), newick::parser::tree, ast);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="comment">// We check by printing the AST if the string was successfully parsed</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::cout &lt;&lt; quoted(s) &lt;&lt; <span class="stringliteral">&quot;\t &quot;</span> &lt;&lt; (ok ? <span class="stringliteral">&quot;Parsed&quot;</span> : <span class="stringliteral">&quot;Failed&quot;</span>);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">if</span> (ok)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;\n\nAbstract Tree Syntax:\n\n&quot;</span> &lt;&lt; ast &lt;&lt; std::endl;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="comment">// Let&#39;s use a recursive lambda until C++23 makes this much simpler</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> populate = [](<span class="keyword">auto</span> &amp;tree_root, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ast_root) {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keyword">static</span> <span class="keyword">auto</span> recurse = [](<span class="keyword">auto</span> &amp;subtree, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ast, <span class="keyword">auto</span> &amp;<span class="keyword">self</span>) <span class="keyword">mutable</span> -&gt; <span class="keywordtype">void</span> {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            <span class="comment">// the idea is simple: traverse the AST ...</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordflow">if</span> (ast.children.size() == 2)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                <span class="comment">// ... by instantiating the children and propagating to the next subtree</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                subtree.left_child = std::unique_ptr&lt;MyNode&gt;(<span class="keyword">new</span> <a class="code" href="structMyNode.html">MyNode</a>{ast.name, ast.distance_to_parent});</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                <span class="keyword">self</span>(*subtree.left_child, ast.children.front(), <span class="keyword">self</span>);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160; </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                subtree.right_child = std::unique_ptr&lt;MyNode&gt;(<span class="keyword">new</span> <a class="code" href="structMyNode.html">MyNode</a>{ast.name, ast.distance_to_parent});</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                <span class="keyword">self</span>(*subtree.right_child, ast.children.back(), <span class="keyword">self</span>);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            }</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        };</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        recurse(tree_root, ast_root, recurse);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    };</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="comment">// Initialize your root using the AST data members</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="structMyNode.html">MyNode</a> my_root{.id = ast.name, .length = ast.distance_to_parent};</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">// And then call the recursion to populate the children</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    populate(my_root, ast);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::cout &lt;&lt; (my_root.left_child == <span class="keyword">nullptr</span> ? <span class="stringliteral">&quot;Failed&quot;</span> : <span class="stringliteral">&quot;Populated&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::cout &lt;&lt; (my_root.right_child == <span class="keyword">nullptr</span> ? <span class="stringliteral">&quot;Failed&quot;</span> : <span class="stringliteral">&quot;Populated&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div>
<div class="ttc" id="astructMyNode_html"><div class="ttname"><a href="structMyNode.html">MyNode</a></div><div class="ttdef"><b>Definition:</b> newick_parser_3.cpp:7</div></div>
</div><!-- fragment --><p><b>Output</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="stringliteral">&quot;(A:0.1,(C:0.3,D:0.4)B:0.5)E;&quot;</span>   Parsed</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Abstract Tree Syntax:</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="stringliteral">&quot;E&quot;</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;├──0.1──<span class="stringliteral">&quot;A&quot;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;└──0.5──<span class="stringliteral">&quot;B&quot;</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    ├──0.3──<span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    └──0.4──<span class="stringliteral">&quot;D&quot;</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;Populated</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Populated</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
